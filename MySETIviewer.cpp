//
// MySETIviewer, an application for viewing, overlaying and manipulating images for display
// relative to eath other for the purpose of examining images generated by MySETIapp
// MySETIviewer.cpp
// (C) 2023, Mark Stegall
// Author: Mark Stegall
//
// This file is part of MySETIviewer.
//
// MySETIviewer is free software : you can redistribute it and /or modify it under
// the terms of the GNU General Public License as published by the Free Software Foundation,
// either version 3 of the License, or (at your option) any later version.
//
// MySETIviewer is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
// without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
// See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with MySETIapp.
// If not, see < https://www.gnu.org/licenses/>. 
//
// Background:
// From the 'A Sign in Space' website, https://asignin.space/:
// A Sign in Space is an interdisciplinary project by media artist Daniela de Paulis,
// in collaboration with the SETI Institute, the European Space Agency,
// the Green Bank Observatory and INAF, the Italian National Institute for Astrophysics.
// The project consists in transmitting a simulated extraterrestrial message as part
// of a live performance, using an ESA spacecraft as celestial source.The objective
// of the project is to involve the world - wide Search for Extraterrestrial
// Intelligence community, professionals from different fieldsand the broader public
// in the reception, decodingand interpretation of the message.This process will
// require global cooperation, bridging a conversation around the topics of SETI,
// space researchand society, across multiple culturesand fields of expertise.
// https://www.seti.org/event/sign-space
// 
// The message was transmitted from the ESA's ExoMars Trace Gas Orbiter (TGO)
//   on May 24 at 19:16 UTC/12:15 pm PDT.
// 
// It was received by three radio telescopes on earth May 24,2023.
// A group of individuals in the Discord 'A Sign in Space' channel
// unscrambled the message from the radio telemetry.
// The message published as Data17.bin is the correctly transcribed
// bitstream of the message payload given to ESA.
// 
// The next step in the problem is the decoding of the payload bitstream into
// the next level of the message.
// 
// The MySETI programs is a set of tools to help in this process.
// This conssists of:
//      MySETIapp    Addresses various messgae extraction and image manipultation
//                   methods the have been tried or are being tried for the purpose
//                   of fruther decoding the 'A Sign In Space' message
//      MySETIviewer Viewer program to load the image files (.raw) that the MySETIapp   
//                   application generates.  It allows the overlay, alignment, and
//                   display of theses file with an interactrive GUI.
// 
// The MySETIviewer covers many of the problems people have had in the Discord group visualizing
// the image data being generated in the decoding process.
//
// V0.1.0.1  2023-12-08 Initial devleopment version of application
// 
//
//  This appliction stores user parameters in a Windows style .ini file
//  The MySETIviewer.ini file must be in the same directory as the exectable
//
//  A lot of this application code is really to support the framework
//  of the application for the user interface.
//
#include "framework.h"
#include <atlstr.h>
#include <strsafe.h>
#include <atlpath.h>
#include <string.h>
#include "AppErrors.h"
#include "MySETIviewer.h"
#include "Layers.h"
#include "AppFunctions.h"
#include "imageheader.h"
#include "FileFunctions.h"

#define MAX_LOADSTRING 100

// Global Variables:
HINSTANCE hInst;                                // current instance
WCHAR szTitle[MAX_LOADSTRING];                  // The title bar text
WCHAR szWindowClass[MAX_LOADSTRING];            // the main window class name

// working filenames
WCHAR szBMPFilename[MAX_PATH] = L"";    // used to save last results file
WCHAR szCurrentFilename[MAX_PATH] = L"";    // used to save last results file
WCHAR szTempDir[MAX_PATH] = L"";        // used as a temporary storage location

// global Class declarations
Layers* ImageLayers = NULL;

// global flags
int DisplayResults = 0;
int AutoScaleResults = 0;
int DefaultRBG = 0;
int AutoSize = 0;
int AutoPNG = 0;

// handle for modeless dialogs and windows
HWND hwndImageDisplay = NULL;  // handle for modeless Display Image window

// color setting tables for Display
COLORREF rgbBackground = 0;      // display background color
COLORREF rgbGapMajor = 0;            // display Grid color
COLORREF rgbGapMinor = 0;             // display Gap color
COLORREF CustomColorTable[16] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };    // array of custom colors

// display image grid size
int GridXmajor;
int GridYmajor;
int GridXminor;
int GridYminor;

// display gap size
int GapXmajor;
int GapYmajor;
int GapXminor;
int GapYminor;

// The following is from the version information in the resource file
CString strProductName;
CString strProductVersion;
CString strName;
CString strCopyright;
CString strAppNameEXE;
CString strAppNameINI;

// handle to the main application window
//  needed to do things like check or uncheck a menu item in the main app
HWND hwndMain = NULL;
HWND hwndImage = NULL;

// Forward declarations of functions included in this code module:
ATOM                MyRegisterClass(HINSTANCE hInstance);
BOOL                InitInstance(HINSTANCE, int);
LRESULT CALLBACK    WndProc(HWND, UINT, WPARAM, LPARAM);


// Declaration for callback dialog procedures in other modules
INT_PTR CALLBACK    AboutDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    SettingsDisplayDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    SettingsLayersDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    SettingsGlobalDlg(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK    ImageDlg(HWND, UINT, WPARAM, LPARAM);

//*******************************************************************************
//
// int APIENTRY wWinMain
//
//*******************************************************************************
int APIENTRY wWinMain(_In_ HINSTANCE hInstance,
                     _In_opt_ HINSTANCE hPrevInstance,
                     _In_ LPWSTR    lpCmdLine,
                     _In_ int       nCmdShow)
{
    UNREFERENCED_PARAMETER(hPrevInstance);
    UNREFERENCED_PARAMETER(lpCmdLine);

    // TODO: Place code here.
    // HeapSetInformation(NULL, HeapEnableTerminationOnCorruption, NULL, 0);

    // 
    // Get version information, executable name including path to executable location
    if (!GetProductAndVersion(&strProductName,
        &strProductVersion,
        &strName,
        &strCopyright,
        &strAppNameEXE))
        return FALSE;

    // create INI file name for application settings
    // The INI file has the same name as the executable.
    // It is located in the same directory as the exectable
    CPath path(strAppNameEXE);
    path.RenameExtension(_T(".ini"));
    strAppNameINI.SetString(path);

    // Initialize global strings
    LoadStringW(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
    LoadStringW(hInstance, IDC_MYSETIVIEWER, szWindowClass, MAX_LOADSTRING);
    MyRegisterClass(hInstance);

    // Perform application initialization:
    if (!InitInstance (hInstance, nCmdShow))
    {
        return FALSE;
    }

    HACCEL hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_MYSETIVIEWER));

    MSG msg;
    BOOL bRet;

    // Main message loop:
    while ((bRet = GetMessage(&msg, nullptr, 0, 0))!=0)
    {
        if (bRet == -1) {
            // error handling if required
        }
        else {
            // Modeless dialog need to process messages intended for the modeless dialog only.
            // Check that message is not for each modeless dialog box.
            //
            if (IsWindow(hwndImage) && IsDialogMessage(hwndImage, &msg)) {
                continue;
            }
            // // Modeless dialog B
            //if (IsWindow(hwndBDlg) && IsDialogMessage(hwndBtDlg, &msg)) {
            //    continue;
            //}

            if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    return (int) msg.wParam;
}


//*******************************************************************************
//
//  FUNCTION: MyRegisterClass()
//
//  PURPOSE: Registers the window class.
//
//*******************************************************************************
ATOM MyRegisterClass(HINSTANCE hInstance)
{
    WNDCLASSEXW wcex;

    wcex.cbSize = sizeof(WNDCLASSEX);

    wcex.style          = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc    = WndProc;
    wcex.cbClsExtra     = 0;
    wcex.cbWndExtra     = 0;
    wcex.hInstance      = hInstance;
    wcex.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_MYSETIVIEWER));
    wcex.hCursor        = LoadCursor(nullptr, IDC_ARROW);
    wcex.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
    wcex.lpszMenuName   = MAKEINTRESOURCEW(IDC_MYSETIVIEWER);
    wcex.lpszClassName  = szWindowClass;
    wcex.hIconSm        = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_MYSETIVIEWER));

    return RegisterClassExW(&wcex);
}

//*******************************************************************************
//
//   FUNCTION: InitInstance(HINSTANCE, int)
//
//   PURPOSE: Saves instance handle and creates main window
//
//   COMMENTS:
//
//        In this function, we save the instance handle in a global variable and
//        create and display the main program window.
//
//*******************************************************************************
BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)
{
   hInst = hInstance; // Store instance handle in our global variable

   HWND hWnd = CreateWindowW(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,
      CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, nullptr, nullptr, hInstance, nullptr);

   if (!hWnd)
   {
      return FALSE;
   }

   // restore main window position from last execution
   CString csString = L"MainWindow";
   RestoreWindowPlacement(hWnd, csString);

   ShowWindow(hWnd, nCmdShow);
   UpdateWindow(hWnd);

   // load globals

   hwndMain = hWnd;
   ImageLayers = new Layers;

   // strings
   WCHAR szString[MAX_PATH];
   GetPrivateProfileString(L"SettingsGlobalDlg", L"BMPresults", L"", szString, MAX_PATH, (LPCTSTR)strAppNameINI);
   wcscpy_s(szBMPFilename, szString);

   GetPrivateProfileString(L"SettingsGlobalDlg", L"TempDir", L"", szString, MAX_PATH, (LPCTSTR)strAppNameINI);
   wcscpy_s(szTempDir, szString);

   GetPrivateProfileString(L"SettingsGlobalDlg", L"CurrentFIlename", L"", szString, MAX_PATH, (LPCTSTR)strAppNameINI);
   wcscpy_s(szCurrentFilename, szString);

   // variables

   DisplayResults = GetPrivateProfileInt(L"SettingsGlobalDlg", L"DisplayResults", 1, (LPCTSTR)strAppNameINI);
   AutoScaleResults = GetPrivateProfileInt(L"SettingsGlobalDlg", L"AutoScaleResults", 1, (LPCTSTR)strAppNameINI);
   AutoSize = GetPrivateProfileInt(L"SettingsGlobalDlg", L"AutoSize", 0, (LPCTSTR)strAppNameINI);
   AutoPNG = GetPrivateProfileInt(L"SettingsGlobalDlg", L"AutoPNG", 1, (LPCTSTR)strAppNameINI);

   rgbBackground = (COLORREF) GetPrivateProfileInt(L"SettingsDisplayDlg", L"rgbBackground", 0, (LPCTSTR)strAppNameINI);
   rgbGapMajor = (COLORREF) GetPrivateProfileInt(L"SettingsDisplayDlg", L"rgbGapMajor", 0, (LPCTSTR)strAppNameINI);
   rgbGapMinor = (COLORREF) GetPrivateProfileInt(L"SettingsDisplayDlg", L"rgbGapMinor", 0, (LPCTSTR)strAppNameINI);
  
   for (int i = 0; i < 16; i++) {
       WCHAR CustomColor[20];
       swprintf_s(CustomColor, 20, L"CustomColorTable%d", i);
       CustomColorTable[i] = (COLORREF) GetPrivateProfileInt(L"SettingsDlg", CustomColor, 0, (LPCTSTR)strAppNameINI);
   }

   GridXmajor = GetPrivateProfileInt(L"SettingsDisplayDlg", L"GridXmajor", 4, (LPCTSTR)strAppNameINI);
   GridXminor = GetPrivateProfileInt(L"SettingsDisplayDlg", L"GridXminor", 2, (LPCTSTR)strAppNameINI);
   GridYmajor = GetPrivateProfileInt(L"SettingsDisplayDlg", L"GridYmajor", 2, (LPCTSTR)strAppNameINI);
   GridYminor = GetPrivateProfileInt(L"SettingsDisplayDlg", L"GridYminor", 2, (LPCTSTR)strAppNameINI);
   GapXmajor = GetPrivateProfileInt(L"SettingsDisplayDlg", L"GapXmajor", 2, (LPCTSTR)strAppNameINI);
   GapXminor = GetPrivateProfileInt(L"SettingsDisplayDlg", L"GapXminor", 1, (LPCTSTR)strAppNameINI);
   GapYmajor = GetPrivateProfileInt(L"SettingsDisplayDlg", L"GapYmajor", 2, (LPCTSTR)strAppNameINI);
   GapYminor = GetPrivateProfileInt(L"SettingsDisplayDlg", L"GapYminor", 1, (LPCTSTR)strAppNameINI);

   COLORREF Color;
   Color = (COLORREF) GetPrivateProfileInt(L"SettingsDlg", L"DefaultColor", 1, (LPCTSTR)strAppNameINI);
   ImageLayers->SetDefaultColor(Color);
   Color = (COLORREF)GetPrivateProfileInt(L"SettingsDlg", L"OverlayColor", 1, (LPCTSTR)strAppNameINI);
   ImageLayers->SetOverlayColor(Color);

   return TRUE;
}

//*******************************************************************************
//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE: Processes messages for the main window.
//
//  WM_COMMAND  - process the application menu
//  WM_PAINT    - Paint the main window
//  WM_DESTROY  - post a quit message and return
//
//
//*******************************************************************************
LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
    case WM_COMMAND:
        {
            int wmId = LOWORD(wParam);
            // Parse the menu selections:
            switch (wmId)
            {
            
            case IDM_LAYER_NEW:
            {
                int NumLayers = ImageLayers->GetNumLayers();
                if (NumLayers == 0) {
                    break;
                }

                ImageLayers->ReleaseOverlay();
                for (int i = NumLayers - 1; i >= 0; i--) {
                    ImageLayers->ReleaseLayer(i);
                }
                break;
            }

            case IDM_LOAD_CONFIGURATION:
            {
                int iRes;
                WCHAR szFilename[MAX_PATH];

                PWSTR pszFilename;
                COMDLG_FILTERSPEC AllType[] =
                {
                     { L"Image files", L"*.cfg" },
                     { L"All Files", L"*.*" },
                };

                if (!CCFileOpen(hWnd, ImageLayers->ConfigurationFile, &pszFilename, FALSE, 2, AllType, L".cfg")) {
                    break;
                }

                wcscpy_s(szFilename, pszFilename);
                CoTaskMemFree(pszFilename);

                iRes = ImageLayers->LoadConfiguration(szFilename);
                if (iRes != APP_SUCCESS) {
                    MessageMySETIviewerError(hWnd, iRes, L"Layers");
                }
                break;
            }

            case IDM_SAVE_CONFIGURATION :
            {
                int iRes;

                if (ImageLayers->GetNumLayers() == 0) {
                    MessageBox(hWnd, L"No layers loaded", L"Layers", MB_OK);
                    break;
                }
                
                if (wcslen(ImageLayers->ConfigurationFile) != 0) {
                    iRes = ImageLayers->SaveConfiguration();
                    if (iRes == APP_SUCCESS) {
                        break;
                    }
                }
                // go ahead with IDM_SAVE_AS_CONFIGURATION
            }
            case IDM_SAVE_AS_CONFIGURATION:
            {
                int iRes;

                if (ImageLayers->GetNumLayers() == 0) {
                    MessageBox(hWnd, L"No layers loaded", L"Layers", MB_OK);
                    break;
                }

                WCHAR szFilename[MAX_PATH];
                
                PWSTR pszFilename;
                COMDLG_FILTERSPEC AllType[] =
                {
                     { L"Image files", L"*.cfg" },
                     { L"All Files", L"*.*" },
                };

                if (!CCFileSave(hWnd, ImageLayers->ConfigurationFile, &pszFilename, FALSE, 2, AllType, L".cfg")) {
                    break;
                }

                wcscpy_s(szFilename, pszFilename);
                CoTaskMemFree(pszFilename);

                iRes = ImageLayers->SaveConfiguration(szFilename);
                if (iRes == APP_SUCCESS) {
                    wcscpy_s(ImageLayers->ConfigurationFile, MAX_PATH, szFilename);
                }
                break;
            }

            case IDM_ADD_LAYER:
            {
                if (ImageLayers->GetNumLayers() >= MAX_LAYERS) {
                    MessageBox(hWnd, L"Max layers reached", L"Layers", MB_OK);
                    break;
                }

                PWSTR pszFilename;
                COMDLG_FILTERSPEC AllType[] =
                {
                     { L"Image files", L"*.raw" },
                     { L"BMP files", L"*.bmp" },
                     { L"All Files", L"*.*" },
                };

                if (!CCFileOpen(hWnd, szCurrentFilename, &pszFilename, FALSE, 3, AllType, L".raw")) {
                    break;
                }

                wcscpy_s(szCurrentFilename, pszFilename);
                CoTaskMemFree(pszFilename);

                int iRes = ImageLayers->AddLayer(szCurrentFilename);
                if (iRes != APP_SUCCESS) {
                    MessageMySETIviewerError(hWnd, iRes, L"Add layer failure");
                    break;
                }
                break;
            }

            case IDM_REMOVE_LAYER:
            {
                DialogBox(hInst, MAKEINTRESOURCE(IDD_SETTINGS_LAYERS), hWnd, SettingsLayersDlg);
                break;
            }

            case IDM_RELOAD_LAYERS:
            {
                int iRes;
                iRes = ImageLayers->GetNumLayers();
                if (iRes == 0) {
                    MessageBox(hWnd, L"No layers to reload\nTry Load configuration", L"Layers", MB_OK);
                    break;
                }
                iRes = ImageLayers->LoadConfiguration(ImageLayers->ConfigurationFile);
                if (iRes != APP_SUCCESS) {
                    MessageMySETIviewerError(hWnd, iRes, L"Layers");
                    break;
                }
                break;
            }

            case IDM_ABOUT:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, AboutDlg);
                break;

            case IDM_SETTINGS_DISPLAY:
                if (wcslen(szTempDir) == 0) {
                    MessageBox(hWnd, L"Working file folder needs to be set\nin Settings->Global first", L"Layers", MB_OK);
                    break;
                }
                DialogBox(hInst, MAKEINTRESOURCE(IDD_SETTINGS_DISPLAY), hWnd, SettingsDisplayDlg);
                break;

            case IDM_SETTINGS_LAYERS:
                if (wcslen(szTempDir) == 0) {
                    MessageBox(hWnd, L"Working file folder needs to be set\nin Settings->Global first", L"Layers", MB_OK);
                    break;
                }
                DialogBox(hInst, MAKEINTRESOURCE(IDD_SETTINGS_LAYERS), hWnd, SettingsLayersDlg);
                break;

            case IDM_SETTINGS_GLOBAL:
                DialogBox(hInst, MAKEINTRESOURCE(IDD_SETTINGS_GLOBAL), hWnd, SettingsGlobalDlg);
                break;

            case IDM_LAYER_SAVEBMP:
            {
                if (!ImageLayers->OverlayValid) {
                    MessageBox(hWnd, L"Overlay is not valid to save\nmake sure current configuration is applied", L"Layers", MB_OK);
                    break;
                }

                PWSTR pszFilename;
                COMDLG_FILTERSPEC AllType[] =
                {
                     { L"BMP files", L"*.bmp" },
                     { L"All Files", L"*.*" }
                };

                if (!CCFileSave(hWnd, szCurrentFilename, &pszFilename, FALSE, 2, AllType, L".bmp")) {
                    break;
                }

                wcscpy_s(szCurrentFilename, pszFilename);
                CoTaskMemFree(pszFilename);

                int iRes;
                iRes = ImageLayers->SaveImageBMP(szCurrentFilename);
                if (iRes != APP_SUCCESS) {
                    MessageBox(hWnd, L"Save Failed", L"Layers", MB_OK);
                }
                break;
            }

            case IDM_EXIT:
                DestroyWindow(hWnd);
                break;
            default:
                return DefWindowProc(hWnd, message, wParam, lParam);
            }
        }
        break;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hWnd, &ps);
            // TODO: Add any drawing code that uses hdc here...
            EndPaint(hWnd, &ps);
        }
        break;
    case WM_DESTROY:
        {   // save window position/size data
            CString csString = L"MainWindow";
            WritePrivateProfileString(L"GlobalSettings", L"CurrentFIlename", szCurrentFilename, (LPCTSTR)strAppNameINI);
            SaveWindowPlacement(hWnd, csString);
            // delete any global classes;
            delete ImageLayers;
        }
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProc(hWnd, message, wParam, lParam);
    }
    return 0;
}

